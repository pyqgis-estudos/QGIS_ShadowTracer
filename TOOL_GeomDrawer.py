# -*- coding: utf-8 -*-
"""
    /***************************************************************************
    ShadowTracer
                                    A QGIS plugin
    Desenho de sombra solar.
    
    Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                                -------------------
            begin                : 2020-05-05
            git sha              : $Format:%H$
            copyright            : (C) 2020 by Marcelo Baliu Fiamenghi
            email                : ma.baliu@gmail.com
    ***************************************************************************/

    /***************************************************************************
    *                                                                         *
    *   This program is free software; you can redistribute it and/or modify  *
    *   it under the terms of the GNU General Public License as published by  *
    *   the Free Software Foundation; either version 2 of the License, or     *
    *   (at your option) any later version.                                   *
    *                                                                         *
    ***************************************************************************/
"""

import numpy as np

class breakerSign:
    """Return 1 when the process should be break

    Breakers based on:
        WORKSPACE
        FLOOR LEVEL
        OBJECT
    """
    def __init__(self, ds_size=None, cx=None, cy=None, cz=None, limits=None, 
                 floor_level=0, refDataset=None):

        self.ds_size = ds_size
        self.cx = cx
        self.cy = cy
        self.cz = cz
        self.limits = limits
        self.floor_level = floor_level
        self.refDataset = refDataset


    def breaker_space(self):
        """Limits into the Workspace
        Used: ds_size, cx, cy"""

        refY, refX = self.ds_size
        if any(
               (any((0 > self.cx, self.cx >= refX)),  # X-axis
                any((0 > self.cy, self.cy >= refY)))):  # Y-axis
            # print(cx, cy, refX, refY)  ##LOGGER-inline
            # print('0 > cx', 0 > cx)  ##LOGGER-inline
            # print('cx >= refX', cx >= refX)  ##LOGGER-inline
            # print('0 > cy', 0 > cy)  ##LOGGER-inline
            # print('cy >= refY', cy >= refY)  ##LOGGER-inline
            # print()  ##LOGGER-inline
            return 1
        else:
            # print(cx, cy, refX, refY)  ##LOGGER-inline
            # print('0 > cx', 0 > cx)  ##LOGGER-inline
            # print('cx >= refX', cx >= refX)  ##LOGGER-inline
            # print('0 > cy', 0 > cy)  ##LOGGER-inline
            # print('cy >= refY', cy >= refY)  ##LOGGER-inline
            # print()  ##LOGGER-inline
            return 0

    def breaker_floor(self):
        """Limits at the floor
        Used: cZ, floor_level"""

        if self.cz < self.floor_level:
            return 1
        else:
            return 0

    def breaker_blockerObj(self):
        """"Limits on a blocker object
        Used: refDataset, cx, cy, cz"""

        if self.refDataset is None:
            return 0
        elif (self.refDataset[self.cy, self.cx] > self.cz):
            return 1
        else:
            return 0

    def updater(self, ds_size=None, cx=None, cy=None, cz=None, limits=None, 
                floor_level=None, refDataset=None):
        if ds_size is not None:
            self.ds_size = ds_size

        if cx is not None:
            self.cx = cx

        if cy is not None:
            self.cy = cy

        if cz is not None:
            self.cz = cz

        if limits is not None:
            self.limits = limits

        if floor_level is not None:
            self.floor_level = floor_level

        if refDataset is not None:
            self.refDataset = refDataset


class GeomDrawer:
    """Toolset with basic elements to draw into a numpy dataset
    """
    def __init__(self):
        pass

    @staticmethod  # Independent method
    def drawPoint(ds, value, x, y, ds_shape=None):
        """Draw point, with check if the point is in the image area

        Arguments:
            ds - Numpy Dataset
            value - cell's value
            x, y {int} - Coordinates
            ds_shape - heigth(Y), width(X) = ds.shape. (Default: {None})
        """

        # Get the height and weight to avoid out space error
        if (ds_shape is None):
            heigth, width = ds.shape
        else:
            heigth, width = ds_shape

        if ((x >= 0) and (x < width) and (y >= 0) and (y < heigth)):
            ds[y, x] = value


    @staticmethod  # Independent method
    def drawLine_fromTwoPoints(ds, value, x0, y0, x1, y1):
        """Draw line segment, given two points
        https://stackoverflow.com/questions/15585303/drawing-diagonal-lines-on-an-image

        From Bresenham's line algorithm
        http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
        É baseado no sistema de erros

        TODO
        Linha antialiased
        https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm 


        # The following is fast implementation and contains side effects...
        """

        dx = abs(x1-x0)    # Difference X
        dy = abs(y1-y0)    # Difference Y
        sx = sy = 0
        zj = value

        #sx = 1 if x0 < x1 else -1
        #sy = 1 if y0 < y1 else -1

        # Directions Setup
        if (x0 < x1):  # X positiv
            sx = 1 
        else: 
            sx = -1
        if (y0 < y1):  # Y positiv
            sy = 1 
        else: 
            sy = -1


        err = dx - dy  #...

        # Starting point
        xj = x0
        yj = y0

        step=0
        while True:  # Tracing
            GeomDrawer.drawPoint(ds, zj, xj, yj, ds_shape=None)
            # drawPoint(pic, color, xj, yj)  # Create pj(xj, yj)

            # POINT IN THE END
            if (xj == x1) and (yj == y1):
                GeomDrawer.drawPoint(ds, zj, xj, yj, ds_shape=None)
                break

            # X Axis
            e2 = 2 * err  # Double Error
            if (e2 > -dy):  # Para dx=0
                err = err - dy  #...
                xj = xj + sx  # Next X pixel
                # xj += sx  # Next X pixel

            # Last point
            if (xj == x1) and (yj == y1):
                GeomDrawer.drawPoint(ds, zj, xj, yj, ds_shape=None)
                break

            # Y Axis
            if (e2 < dx):
                err = err + dx
                yj = yj + sy 
                # yj += sy
            
            step += 1
            if step > 100:
                break


    @staticmethod
    def drawValidate(cX, cY, cValue, cDS, refDS):
        """Valida se o pixel possui um valor inferior ao valor que se deseja
        inserir. Caso contrário, reprovado a alteração do pixel

        *Valor superior ao de referencia*
        cX, cY - current Coordinate
        cValue - current Value (current Z)
        cDS - current Dataset
        ref - reference of dataset

        RETURN:
            True - To draw
            False - Not to draw
        """
        #PLEONASMO


        if refDS is not None:  # Exists REF
            if cDS[cY, cX] > cValue:  # SelfLayer
                return False
            elif refDS[cY, cX] > cValue:  # RefLayer
                return False
            else:
                return True
        else:  # No REF
            if cDS[cY, cX] > cValue:  # SelfLayer
                return False
            else:
                return True

    @staticmethod  # Independent method
    def drawLine(
            ds,
            value,
            x0,
            y0,
            angle=0,
            angZ=0,
            cell_size=1,
            steps=99999,
            limits=0,
            ref_ds=None,
            method='bresenham',
            log=False,
            firstPoint=True, lastPoint=True):
        """ Draws a line through a directions(angle) and a 

        PARAMETERS:
        method - Method to calculate the pixel os the line.
                OPTIONS
                'bresenham' [std]
                    Based on the calculation of the Bresenham's method. 
                    It's error based method.
                    http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
                'sin'
                    Based on the nearst integer from the sin and cos values
                'wu' [TODO]
                    Based on the Xiaolin Wu's method.
                    https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm 
        """

        #    1. SETUP THE VARIABLE
        # Dataset size
        ds_shape = ds.shape
        # Azimuth
        # the normal angle starts with 0 to the right
        ang = angle - 90
        #Coordenates of the Point(j)
        xj = x0
        yj = y0
        zj = value

        # Maths calculations
        sin_value = np.sin(np.radians(ang))
        cos_value = np.cos(np.radians(ang))
        tan_z = np.tan(np.radians(angZ)) * cell_size

        if method == 'bresenham':
            # DIRECTION SETUP
            if sin_value > 0:
                sY = 1
            else:
                sY = -1
            if cos_value > 0:
                sX = 1
            else:
                sX = -1

            # Difference Values
            dx = abs(cos_value)
            dy = abs(sin_value)
            err = dx - dy

            xjp = xj
            yjp = yj


        # Steps or length
        step = 0

        # MAKER
        breaker = breakerSign(ds_size=ds_shape,
                              floor_level=0,
                              refDataset=ref_ds,
                              limits=None)
        # breaker = breakerSign(ds_size=ds_shape, cx=xjp, cy=yjp, cz=zj, floor_level=0, refDataset=ref_ds, limits=None)  #Full
        while True:
            if method == 'bresenham':

                # Breaker - Workspace and floor
                breaker.updater(cx=xjp, cy=yjp, cz=zj)
                if breaker.breaker_space() or breaker.breaker_floor():
                    break

                #    CREATOR
                # Creation validator
                if all(((firstPoint or (step != 0)),  # Validates the first point
                        GeomDrawer.drawValidate(  # Validates the necessity of the creation
                            cX=xjp,
                            cY=yjp,
                            cValue=zj,
                            cDS=ds,
                            refDS=ref_ds))):

                    # Breaker OBJ
                    if breaker.breaker_blockerObj():
                        break

                    # Create a pixel
                    GeomDrawer.drawPoint(ds, zj, xjp, yjp, ds_shape=ds_shape)
                else:
                    pass

                # # LIMITE DE PROJEÇÃO
                # if breaker(ds, xjp, yjp, zj, limits=limits):
                #     break

                e2 = 2 * err  # Double Error

                # X Axis
                if e2 > -dy:  # Para dx=0
                    err -= dy  # Updating error
                    xjp += sX  # Next X pixel

                # # LIMITE DE PROJEÇÃO
                # if breaker(ds, xjp, yjp, zj, limits=limits):
                #     break

                # Y Axis
                if e2 < dx:
                    err += dx
                    yjp += sY

                zj -= tan_z

            elif method == 'sin':  # SIN Method TODO
                # Adaptive coordenates of Point(j)
                xjp, yjp = (int(round(xj)), int(round(yj)))  # Nearst integer
                # xjp, yjp = (int(xj), int(yj))  # Floor round

                # LIMITE DE PROJEÇÃO
                # if breaker(ds, xjp, yjp, zj, limits=limits):  # DEPRECATED
                #     break

                # Create a pixel
                GeomDrawer.drawPoint(ds, zj, xjp, yjp, ds_shape=ds_shape)


                # Current Point(j) - to logger
                x_log = xj
                y_log = yj
                # NEXT Point(j)
                xj += cos_value
                yj += sin_value
                zj -= tan_z # Implementar Z - Aqui considera 1 pixel um metro TODO


                if log:  ##LOGGER-inline
                    print("Real X:", round(x_log,1), int(x_log),  ##LOGGER-inline
                          " ; Real Y:", round(y_log, 1), int(y_log))  ##LOGGER-inline

            else:
                print('No method choosen')

            # Steps validator
            step += 1
            if step > steps:
                break
            